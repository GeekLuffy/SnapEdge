{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///F:/SnapEdge/src/lib/telegram.ts"],"sourcesContent":["export interface TelegramFileResult {\r\n  file_id: string;\r\n  file_unique_id: string;\r\n  file_path?: string;\r\n}\r\n\r\nexport async function uploadToTelegram(file: Blob, fileName: string): Promise<TelegramFileResult> {\r\n  const token = process.env.TELEGRAM_BOT_TOKEN;\r\n  const chatId = process.env.TELEGRAM_CHAT_ID;\r\n\r\n  if (!token || !chatId) {\r\n    throw new Error('Telegram credentials not configured');\r\n  }\r\n\r\n  const formData = new FormData();\r\n  formData.append('chat_id', chatId);\r\n  formData.append('photo', file, fileName);\r\n\r\n  const response = await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {\r\n    method: 'POST',\r\n    body: formData,\r\n  });\r\n\r\n  const data = await response.json();\r\n\r\n  if (!data.ok) {\r\n    throw new Error(`Telegram API error: ${data.description}`);\r\n  }\r\n\r\n  // Telegram returns an array of sizes, we take the largest one\r\n  const photos = data.result.photo;\r\n  const largestPhoto = photos[photos.length - 1];\r\n\r\n  return {\r\n    file_id: largestPhoto.file_id,\r\n    file_unique_id: largestPhoto.file_unique_id,\r\n  };\r\n}\r\n\r\nexport async function getTelegramFileUrl(fileId: string): Promise<string> {\r\n  const token = process.env.TELEGRAM_BOT_TOKEN;\r\n\r\n  if (!token) {\r\n    throw new Error('Telegram token not configured');\r\n  }\r\n\r\n  const response = await fetch(`https://api.telegram.org/bot${token}/getFile?file_id=${fileId}`);\r\n  const data = await response.json();\r\n\r\n  if (!data.ok) {\r\n    throw new Error(`Telegram API error: ${data.description}`);\r\n  }\r\n\r\n  const filePath = data.result.file_path;\r\n  return `https://api.telegram.org/file/bot${token}/${filePath}`;\r\n}\r\n"],"names":[],"mappings":";;;;;;AAMO,eAAe,iBAAiB,IAAU,EAAE,QAAgB;IACjE,MAAM,QAAQ,QAAQ,GAAG,CAAC,kBAAkB;IAC5C,MAAM,SAAS,QAAQ,GAAG,CAAC,gBAAgB;IAE3C,IAAI,CAAC,SAAS,CAAC,QAAQ;QACrB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,WAAW,IAAI;IACrB,SAAS,MAAM,CAAC,WAAW;IAC3B,SAAS,MAAM,CAAC,SAAS,MAAM;IAE/B,MAAM,WAAW,MAAM,MAAM,CAAC,4BAA4B,EAAE,MAAM,UAAU,CAAC,EAAE;QAC7E,QAAQ;QACR,MAAM;IACR;IAEA,MAAM,OAAO,MAAM,SAAS,IAAI;IAEhC,IAAI,CAAC,KAAK,EAAE,EAAE;QACZ,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,KAAK,WAAW,EAAE;IAC3D;IAEA,8DAA8D;IAC9D,MAAM,SAAS,KAAK,MAAM,CAAC,KAAK;IAChC,MAAM,eAAe,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE;IAE9C,OAAO;QACL,SAAS,aAAa,OAAO;QAC7B,gBAAgB,aAAa,cAAc;IAC7C;AACF;AAEO,eAAe,mBAAmB,MAAc;IACrD,MAAM,QAAQ,QAAQ,GAAG,CAAC,kBAAkB;IAE5C,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,WAAW,MAAM,MAAM,CAAC,4BAA4B,EAAE,MAAM,iBAAiB,EAAE,QAAQ;IAC7F,MAAM,OAAO,MAAM,SAAS,IAAI;IAEhC,IAAI,CAAC,KAAK,EAAE,EAAE;QACZ,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,KAAK,WAAW,EAAE;IAC3D;IAEA,MAAM,WAAW,KAAK,MAAM,CAAC,SAAS;IACtC,OAAO,CAAC,iCAAiC,EAAE,MAAM,CAAC,EAAE,UAAU;AAChE"}},
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///F:/SnapEdge/src/lib/db.ts"],"sourcesContent":["import fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { Redis } from '@upstash/redis';\r\n\r\nconst DB_PATH = path.join(process.cwd(), 'db.json');\r\n\r\nconst redis = (process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN)\r\n    ? new Redis({\r\n        url: process.env.UPSTASH_REDIS_REST_URL,\r\n        token: process.env.UPSTASH_REDIS_REST_TOKEN,\r\n    })\r\n    : null;\r\n\r\nconst useCloud = () => !!redis;\r\n\r\nexport interface ImageRecord {\r\n    id: string;\r\n    telegram_file_id: string;\r\n    created_at: number;\r\n    views: number;\r\n    metadata: {\r\n        size: number;\r\n        type: string;\r\n    };\r\n}\r\n\r\nasync function ensureLocalDb() {\r\n    try {\r\n        await fs.access(DB_PATH);\r\n    } catch {\r\n        await fs.writeFile(DB_PATH, JSON.stringify({ images: [] }));\r\n    }\r\n}\r\n\r\nexport async function saveImage(record: any) {\r\n    if (useCloud() && redis) {\r\n        // Use HSET to store as a single Hash object in Redis\r\n        await redis.hset(`snap:${record.id}`, {\r\n            ...record,\r\n            views: 0,\r\n            metadata: JSON.stringify(record.metadata)\r\n        });\r\n        return;\r\n    }\r\n\r\n    await ensureLocalDb();\r\n    const content = await fs.readFile(DB_PATH, 'utf-8');\r\n    const db = JSON.parse(content);\r\n    db.images.push({ ...record, views: 0 });\r\n    await fs.writeFile(DB_PATH, JSON.stringify(db, null, 2));\r\n}\r\n\r\nexport async function getImage(id: string): Promise<ImageRecord | null> {\r\n    if (useCloud() && redis) {\r\n        // Increment views and get data from the SAME hash object\r\n        await redis.hincrby(`snap:${id}`, 'views', 1);\r\n        const data: any = await redis.hgetall(`snap:${id}`);\r\n\r\n        if (!data || Object.keys(data).length === 0) return null;\r\n\r\n        return {\r\n            ...data,\r\n            id,\r\n            views: parseInt(data.views || '0'),\r\n            created_at: parseInt(data.created_at),\r\n            metadata: typeof data.metadata === 'string' ? JSON.parse(data.metadata) : data.metadata\r\n        } as ImageRecord;\r\n    }\r\n\r\n    try {\r\n        await ensureLocalDb();\r\n        const content = await fs.readFile(DB_PATH, 'utf-8');\r\n        const db = JSON.parse(content);\r\n        const index = db.images.findIndex((img: any) => img.id === id);\r\n        if (index !== -1) {\r\n            db.images[index].views = (db.images[index].views || 0) + 1;\r\n            await fs.writeFile(DB_PATH, JSON.stringify(db, null, 2));\r\n            return db.images[index];\r\n        }\r\n        return null;\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function generateId() {\r\n    return Math.random().toString(36).substring(2, 10);\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAEA,MAAM,UAAU,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAEzC,MAAM,QAAQ,AAAC,QAAQ,GAAG,CAAC,sBAAsB,IAAI,QAAQ,GAAG,CAAC,wBAAwB,GACnF,IAAI,wKAAK,CAAC;IACR,KAAK,QAAQ,GAAG,CAAC,sBAAsB;IACvC,OAAO,QAAQ,GAAG,CAAC,wBAAwB;AAC/C,KACE;AAEN,MAAM,WAAW,IAAM,CAAC,CAAC;AAazB,eAAe;IACX,IAAI;QACA,MAAM,gIAAE,CAAC,MAAM,CAAC;IACpB,EAAE,OAAM;QACJ,MAAM,gIAAE,CAAC,SAAS,CAAC,SAAS,KAAK,SAAS,CAAC;YAAE,QAAQ,EAAE;QAAC;IAC5D;AACJ;AAEO,eAAe,UAAU,MAAW;IACvC,IAAI,cAAc,OAAO;QACrB,qDAAqD;QACrD,MAAM,MAAM,IAAI,CAAC,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE,EAAE;YAClC,GAAG,MAAM;YACT,OAAO;YACP,UAAU,KAAK,SAAS,CAAC,OAAO,QAAQ;QAC5C;QACA;IACJ;IAEA,MAAM;IACN,MAAM,UAAU,MAAM,gIAAE,CAAC,QAAQ,CAAC,SAAS;IAC3C,MAAM,KAAK,KAAK,KAAK,CAAC;IACtB,GAAG,MAAM,CAAC,IAAI,CAAC;QAAE,GAAG,MAAM;QAAE,OAAO;IAAE;IACrC,MAAM,gIAAE,CAAC,SAAS,CAAC,SAAS,KAAK,SAAS,CAAC,IAAI,MAAM;AACzD;AAEO,eAAe,SAAS,EAAU;IACrC,IAAI,cAAc,OAAO;QACrB,yDAAyD;QACzD,MAAM,MAAM,OAAO,CAAC,CAAC,KAAK,EAAE,IAAI,EAAE,SAAS;QAC3C,MAAM,OAAY,MAAM,MAAM,OAAO,CAAC,CAAC,KAAK,EAAE,IAAI;QAElD,IAAI,CAAC,QAAQ,OAAO,IAAI,CAAC,MAAM,MAAM,KAAK,GAAG,OAAO;QAEpD,OAAO;YACH,GAAG,IAAI;YACP;YACA,OAAO,SAAS,KAAK,KAAK,IAAI;YAC9B,YAAY,SAAS,KAAK,UAAU;YACpC,UAAU,OAAO,KAAK,QAAQ,KAAK,WAAW,KAAK,KAAK,CAAC,KAAK,QAAQ,IAAI,KAAK,QAAQ;QAC3F;IACJ;IAEA,IAAI;QACA,MAAM;QACN,MAAM,UAAU,MAAM,gIAAE,CAAC,QAAQ,CAAC,SAAS;QAC3C,MAAM,KAAK,KAAK,KAAK,CAAC;QACtB,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,MAAa,IAAI,EAAE,KAAK;QAC3D,IAAI,UAAU,CAAC,GAAG;YACd,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,IAAI;YACzD,MAAM,gIAAE,CAAC,SAAS,CAAC,SAAS,KAAK,SAAS,CAAC,IAAI,MAAM;YACrD,OAAO,GAAG,MAAM,CAAC,MAAM;QAC3B;QACA,OAAO;IACX,EAAE,OAAM;QACJ,OAAO;IACX;AACJ;AAEO,SAAS;IACZ,OAAO,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG;AACnD"}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":["file:///F:/SnapEdge/src/app/api/v1/upload/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { uploadToTelegram } from '@/lib/telegram';\r\nimport { saveImage, generateId } from '@/lib/db';\r\n\r\n/**\r\n * @api {post} /api/v1/upload Upload an image\r\n * @apiName Upload\r\n * @apiGroup Image\r\n * \r\n * @apiParam {File} file Image file to upload (required)\r\n * @apiParam {String} [customId] Optional custom vanity slug\r\n */\r\nexport async function POST(req: NextRequest) {\r\n    try {\r\n        const formData = await req.formData();\r\n        const file = formData.get('file') as Blob;\r\n        const customId = formData.get('customId') as string;\r\n\r\n        if (!file) {\r\n            return NextResponse.json({\r\n                success: false,\r\n                error: { code: 'MISSING_FILE', message: 'No file provided in request' }\r\n            }, { status: 400 });\r\n        }\r\n\r\n        // 1. Upload to Telegram\r\n        const telegramResult = await uploadToTelegram(file, 'upload.jpg');\r\n\r\n        // 2. Generate ID\r\n        const id = customId ? customId.toLowerCase().replace(/[^a-z0-9-]/g, '-') : generateId();\r\n\r\n        const record = {\r\n            id,\r\n            telegram_file_id: telegramResult.file_id,\r\n            created_at: Date.now(),\r\n            metadata: {\r\n                size: file.size,\r\n                type: file.type,\r\n                version: 'v1'\r\n            }\r\n        };\r\n\r\n        // Save to DB\r\n        await saveImage(record);\r\n\r\n        const baseUrl = process.env.NEXT_PUBLIC_BASE_URL ||\r\n            (req.headers.get('host') ? `http://${req.headers.get('host')}` : '');\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            data: {\r\n                id,\r\n                url: `${baseUrl}/i/${id}`,\r\n                direct_url: `${baseUrl}/i/${id}.jpg`,\r\n                timestamp: record.created_at\r\n            }\r\n        });\r\n\r\n    } catch (error: any) {\r\n        console.error('Upload API Error:', error);\r\n        return NextResponse.json({\r\n            success: false,\r\n            error: { code: 'INTERNAL_ERROR', message: error.message || 'Server processed request failed' }\r\n        }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAUO,eAAe,KAAK,GAAgB;IACvC,IAAI;QACA,MAAM,WAAW,MAAM,IAAI,QAAQ;QACnC,MAAM,OAAO,SAAS,GAAG,CAAC;QAC1B,MAAM,WAAW,SAAS,GAAG,CAAC;QAE9B,IAAI,CAAC,MAAM;YACP,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACrB,SAAS;gBACT,OAAO;oBAAE,MAAM;oBAAgB,SAAS;gBAA8B;YAC1E,GAAG;gBAAE,QAAQ;YAAI;QACrB;QAEA,wBAAwB;QACxB,MAAM,iBAAiB,MAAM,IAAA,4IAAgB,EAAC,MAAM;QAEpD,iBAAiB;QACjB,MAAM,KAAK,WAAW,SAAS,WAAW,GAAG,OAAO,CAAC,eAAe,OAAO,IAAA,gIAAU;QAErF,MAAM,SAAS;YACX;YACA,kBAAkB,eAAe,OAAO;YACxC,YAAY,KAAK,GAAG;YACpB,UAAU;gBACN,MAAM,KAAK,IAAI;gBACf,MAAM,KAAK,IAAI;gBACf,SAAS;YACb;QACJ;QAEA,aAAa;QACb,MAAM,IAAA,+HAAS,EAAC;QAEhB,MAAM,UAAU,6DACZ,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,OAAO,CAAC,GAAG,CAAC,SAAS,GAAG,EAAE;QAEvE,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,MAAM;gBACF;gBACA,KAAK,GAAG,QAAQ,GAAG,EAAE,IAAI;gBACzB,YAAY,GAAG,QAAQ,GAAG,EAAE,GAAG,IAAI,CAAC;gBACpC,WAAW,OAAO,UAAU;YAChC;QACJ;IAEJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,qBAAqB;QACnC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,OAAO;gBAAE,MAAM;gBAAkB,SAAS,MAAM,OAAO,IAAI;YAAkC;QACjG,GAAG;YAAE,QAAQ;QAAI;IACrB;AACJ"}}]
}